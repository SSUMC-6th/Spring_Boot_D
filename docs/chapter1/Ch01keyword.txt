- TCP
IP프로토콜을 기반으로 구현되어 있고, 전송계층에서 사용되는 프로토콜중 하나이다.
참고로 프로토콜은 템플릿같은 느낌으로 이해하면 된다.
양방향 소통 - 3way-handshake :syn, ack/syn, ack 세 가지의 과정으로 이뤄지고, 이로 인해 연결지향성이다.
바이트 스트림을 통해 연결한다.

- UDP
TCP와 마찬가지로 IP프로토콜을 기반으로 구현되어 있다.
데이터의 전달속도만을 중시한다면, UDP프로토콜을 사용하면 된다.
메세지 스트림을 통해 연결한다.

- 시스템 콜?
user 영역과 kernel 영역을 연결 해주기 위한 인터페이스이다.
그렇다면 kernel영역은 무엇인가? -> 우리는 서버 파트니까 인텔리제이로 API를 만들고 있다고 생각해보자.
우리가 작업하고 있는 영역이 바로 user영역이다. kernel영역은 보통은 손대지 않는다.
특히 보통 사용하는 windows 같은 경우에는 수정이 안되도록 되어있다. 리눅스를 사용한다면, 커널영역에 직접 접근할수있다.
kernel영역은 하드웨어와 직접 맞닿아있는 부분을 관할하는데, 우리는 알게 모르게 시스템 콜을 호출하게 된다.
예를들어, int x = 1; 이라고 했으면, x라는 변수의 주소를 read()시스템콜을 호출해서 읽고, write()시스템콜을 호출해서 x의 주소에 1이라는 값을 쓰게 된다.

- 하드웨어 인터럽트
cpu가 아닌 다른 하드웨어 장치가 cpu에게 서비스 요청하는 것.

- 리눅스의 파일과 파일 디스크립터
리눅스에서는 모든 것을 파일로 취급한다.
파일 디스크립터란 말 그대로 파일에 대한 정보를 말한다.
예를들어, 파일 디스크립터가 소켓의 파일 디스크립터인 경우, 소켓에 데이터를 작성(데이터 송신) 혹은 소켓의 데이터를 읽어들이는(데이터 수신) 동작을 하게 된다.

- socket() 시스템 콜
파일 디스크립터를 반환, 도메인, 타입, 프로토콜을 미리 선택한다.
쉽게 말해서 소켓을 만드는 시스템 콜이다.
TCP or UDP 사용? ipv4 or ipv6 통신 사용? 할지 결정한다.
위에서 언급했던 파일 디스크립터를 반환한다.

- bind() 시스템 콜
IP, port를 할당한다.
클라이언트의 경우, 포트가 자동으로 부여되기 때문에, 서버에서만 사용한다.
socket() 시스템 콜로 생성한 파일 디스크립터로 식별해서 포트를 부여한다.

- listen() 시스템 콜
백로그 큐 생성, 연결지향인 TCP프로토콜만 사용한다.
왜 연결지향인 TCP프로토콜에서만 사용할까? 순서와 연결이 중요시 되는 TCP 프로토콜에서 클라이언트의 요청들을 담아놓을 자료구조가 필요하기 때문이다.
연결지향이 아닌 UDP에서는 굳이 연결이 될 필요가 없고, 요청이 오는대로 받아들이기만 하면 되기 때문에 이러한 자료구조가 필요없다.

- accept() 시스템 콜
백로그 큐에서 syn을 보내와 대기중인 요청 fifo(first in first out)로 연결한다.
그러므로, 클라이언트에게 응답을 주기위해서 이후 새로운 소켓을 만들어야한다.

- 멀티 프로세스
쉽게 설명하기 위해서 우리가 일반적으로 코드를 짠다고 생각해보자.
코드를 다 짰는가? 그게 바로 프로그램이다.
그리고 그걸 실행시키면 그게 바로 프로세스이다.
그럼 멀티 프로세스란 무엇인가? 프로그램을 더 빨리, 더 효율적으로 실행시키는 것을 멀티 프로세스라고 이해할수 있다.
프로그램 자체를 처리 하기 위한 흐름이 하나 더 있다고 생각하면 된다.
멀티 스레딩과 달리 모든 데이터를 공유하기 때문에, 자원할당에 많은 주의를 기울여야한다.

- 병렬처리
위에서 언급한 멀티 프로세스, 멀티 스레드와 같은 상황에서 동시에 프로그램을 처리하는 방식을 뜻한다.
특히, 데이터 부분(전역변수)만 공유하는 멀티스레딩 상황에서는 공유자원(전역변수)에 접근할때, consistency(일관성)이 깨질수 있으므로, syncronization과 같이 일관성을 유지하는 동기화 전략이 필요하고, 주의깊게 사용해야한다.
잘만 사용한다면, 전체 throghput(총 처리량), avarage response time 등등 성능 개선에 도움을 줄 수 있다.
