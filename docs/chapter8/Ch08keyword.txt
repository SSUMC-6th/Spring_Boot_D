- Spring의 의존성 주입
  
  dependency injection(DI)라고 부른다. 흔히 new로 생성하는 인스턴스를 외부에서 주입받는 것이다.  한 객체가 다른 객체를 사용하려면 의존성이 있다고한다.
  여러가지 주입방법이 있지만, 공식문서를 확인하면 생성자를 통해 주입하라고 한다. 인자로 인스턴스를 넘겨주면 된다.
  더욱 세밀하게 따져보면 약한 의존성주입이 정확하다. 강하다? 약하다? 구현클래스에 의존하게 된다면 원하는 정보가 바뀔때마다 생성자의 매개변수를 바꿔줘야하는 번거로움이    생긴다. 이를 인터페이스에 의존하도록 바꾸면? 이런 번거로움이 없어진다. 이걸 바로 약한 의존성주입이라고한다.
  주의할 점으로는 한번 생성된 객체를 불변하게 할 수 있다.

- Bean

  우선 Bean이라는 개념은 Spring 프레임워크에서 등장하는 개념이고, 쉽게 말하면 Java언어에서의 객체에 해당한다. 더 정확히 하자면 스프링 컨테이너가 관리하는 재사용 가능한 
  Java객체이다. 그래서 우리는 @Bean등과 같이 간단한 어노테이션 하나 만으로 위에서 언급한 생성자주입을 가능하게 할수있다.
  Spring에서의 DI는 위에서 말했듯이 한번 생성된 객체를 불변하게 할 수 있다고 했는데 왜그럴까? 싱글톤이라는 개념을 알면 이해할수있다. 그래서 실제로 사용할때 주의 할점은 
  빈으로 등록된 객체를 사용하기 위해 클래스 내부에 선언해줄때, final 키워드를 꼭!!! 붙여줘야한다.
  @Repository, @Service, @RestController 등 우리가 알게 모르게 사용하는 이 어노테이션을 타고 들어가서보면 클래스 위에 @Component라고 붙여져있는걸 확인할수 있다.
  이런것들이 전부 Bean이다!

- 싱글톤 : 여러 번 빈을 요청하더라도 매번 동일한 객체를 돌려주는 방

  Spring FrameWork는 기본적으로 BeanFactory를 상속받는 Application Context에 의해 등록된 Bean을 싱글톤으로 관리한다.
  왜? Spring은 그냥 서버개발하기 위한 프레임워크가 아니다! 물론 서버 개발을 위해 많은 기능을 제공하지만, 그냥 서버개발은 순수Java만으로도 할수있다.
  그렇다면 Spring은 무엇이냐? 대규모의 서버 프로젝트를 위한 프레임워크이다. 그래서 싱글톤을 사용하면 대규모 트래픽을 처리할수 있게된다.
  빈 요청이 올때마다 객체가 따로 생성된다고 생각해보자. 한명의 사용자만 있더라도 엄청 많이 생성될것인데, 카카오, 네이버 등등 큰회사에서 이렇게 된다면 그냥 어플이 멈출
  것이다.
  
- IoC 컨테이너
    
  inversion of control(제어의 역전) 개발자가 메소드나, 객체를 호출하는 것이아니라, 그역할을 프레임 워크에게 위임하는것
  사실 위에서 언급한 DI와 IoC의 관계는, DI를 하기위해서 당연하게 IoC라는 기능이 필요한것이다.
  그렇다면 IoC컨테이너가 하는 역할을 개발자가 지정해주는 방법은 무엇이 있을까? 대표적인 예시로는 Spring Security, Spring Data Redis, WebClient, RestTemplate 등등 내가   원하는 설정을 해주기 위해 말그대로 @Configuration 어노테이션을 붙인 클래스에 코딩해주면 스프링 프레임워크에 있는 Application Context라는 친구가 가장 먼저
  @Configuration라고 붙은 클래스들을 검사해서 내가 원하는 의존성을 주입할수 있다.

- RestContollerAdvice
    
  RestController에서 발생하는 Exception 감지하는 역할
  단순 ControllerAdvice와 비교했을때 ResponseBody로 예외에대한 응답을 추가해주는 기능을 제공한다.

- lombok
  
  어노테이션을 기반으로 코드를 자동완성 해주는 라이브러리.
  @Getter @Setter @NoArgsConstructor @AllArgsConstructor @RequiredArgsConstructor 등등이 자주 쓰인다.

RestControllerAdvice은 ControllerAdivce와 더불어 전역으로 예외를 처리할 수 있다. RestController에서 호출한 함수로 인해 실행되는 함수에서 발생하는 예외는 전부 Advice의 관리대상이다.
또한 응답을 JSON으로 내려주고, try-catch문이 없어, 코드의 가독성이 높다.
이와 같은 어노테이션이 없을경우, 예외가 있는 부분마다 코드를 작성해주어야 해서, 번거롭고 코드의 재사용성도 없어진다. 또한 단일책임의 원칙에 어긋나게 로직이 다른 코드들이 서로 뒤얽힐수 있다. 그리고 무엇보다 프로젝트 규모가 커지게 될 경우에 일관성이없고 나중에 내가 무슨 코드를 작성한지 잘 모르게된다.
