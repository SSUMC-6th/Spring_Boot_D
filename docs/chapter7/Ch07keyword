


[영속성 컨텍스트]
: 서버와 데이터베이스 사이에 엔티티를 저장하는 논리적인 영역, 엔티티를 영구 저장하는 환경

-엔티티 매니저를 생성할 때 만들어짐

-엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리함

<장점>
1. 1차 캐시
	- 1차캐시 : 영속성 컨텍스트 내부의 캐시, 영속 상태의 엔티티 저장
	- 엔티티를 키-값으로 관리함 : key가 @Id, value가 엔티티 인스턴스
	- 조회 흐름 : 1차 캐시에서 엔티티 찾기
				-> 있으면 1차 캐시에서 엔티티 조회
				-> 없으면 데이터베이스에서 조회
				-> 조회한 데이터로 엔티티 생성하여 1차 캐시에 저장
				-> 조회한 엔티티 반환

2.동일성 보장
	- 새로운 객체가 아닌 동일 객체가 반환됨
	- cf) 동일성 비교(==) : 인스턴스가 같음
		동등성 비교(.equals()) : 인스턴스가 갖고 있는 값이 같음

3.트랜잭션으로 인한 쓰기 지연
	- 영속성 컨텍스트는 트랜잭션 범위 안에서 동작하므로 트랜잭션이 끝나야 Commit이 이루어지고 반영됨
	- 엔티티 매니저는 트랜잭션을 바로 커밋하지 않고, 내부 쿼리 저장소에 모아두었다가 모아둔 쿼리를 트랜잭션을 커밋할 때 보냄

4.Lazy 로딩
	- 조회 시점이 아닌 필요한 시점에 연관된 객체의 데이터를 불러오는 것
	- 엔티티와 관계가 맺어진 엔티티의 데이터를 가져올 수 있음
	<-> 즉시 로딩(Eager) : 데이터 조회 시, 연관된 모든 객체의 데이터까지 한 번에 불러옴

5.변경 감지
	- 엔티티 수정 시, 엔티티 조회해서 데이터 변경하면 됨
	- 변경 감지 흐름 : 트랜잭션 커밋
					-> 엔티티와 스냅샷 비교하여 변경된 엔티티 찾음
					-> 변경된 엔티티있으면 수정 쿼리를 생성해서 쓰기 지연 저장소에 저장
					-> 쓰기 지연 저장소의 SQL을 flush(영속성 컨텍스트 변경 내용 DB에 반영)
					-> 데이터베이스 트랜잭션 커밋

[양방향 매핑]
@OneToMany
@ManyToOne
<연관관계의 주인>
: 두 연관관계 중 하나는 연관관계의 주인이 됨
: 주인 - 외래 키를 관리(등록, 수정, 삭제) 가능, mappedBy 속성 사용 x!!
: 주인 x - 읽기만 가능, mappedBy 속성 사용하여 주인 지정!

-연관관계의 주인은 테이블에 외래 키가 있는 곳!! : 즉, “다” 쪽이 주인!
	- 1 : @OneToMany, mappedBy o
	- 다 : @ManyToOne, 항상 주인이므로 mappedBy x

[N+1 문제]
: ORM 기술에서 특정 객체를 대상으로 수행한 쿼리가 해당 객체가 가지고 있는 연관관계 또한 조회하게 되면서 N번의 추가적인 쿼리가 발생하는 문제
-원인: JPA Repository로 find 실행시 첫 쿼리에서 하위 엔티티까지 한 번에 가져오는 것이 아니라, 하위 엔티티를 사용할때 추가로 조회함, 한쪽 테이블만 조회하고 다른 테이블은 따로 조회하기 때문.
-해결:
	- @-ToOne : Fetch Join(조회 주체가 되는 entity + 연관 entity까지 모두 영속화)으로 미리 두 테이블을 JOIN하여 데이터 가져오기
	- @-ToMany : BatchSize(WHERE 절이 같은 여러 개의 SELECT 쿼리들을 하나의 IN 쿼리로 만들어줌)