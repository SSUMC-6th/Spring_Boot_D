[Spring의 의존성 주입]

<DI 3가지 방법>
1) 필드 주입 : 생성자빼고 @Autowired -> 별로 안 좋음
2) setter 주입 : 단점 -> public으로 열려있어야 함. 변경으로 인한 문제 발생가능
3) 생성자 주입 : @Autowired, 1번 호출 보장, 불변(static), 필수(private final)
=> 의존관계가 실행중 동적으로 변하는 경우가 거의 없으므로 생성자 주입이 best!!

<생성자 주입 장점>
1) 불변 -> 객체 생성시 1번만 호출되므로 불변
2) 누락 방지 -> 주입 데이터가 누락되면 컴파일 오류 발생
3) fianl 키워드 -> 생성자 주입만 사용가능! 값이 설정되지 않는 오류를 컴파일 시점에서 막아줌

<@Autowired>
: 의존 관계를 자동으로 주입해준다!
: 생성자에 붙음
: 객체 생성 시점에 스프링이 연관된 객체를 스프링 컨테이너에서 찾아서 주입해준다!!
 -> DI, (생성자가 하나라면 @Autowired 생략가능)


[IoC 컨테이너]

<IoC(제어의 역전)>
: 프로그램의 제어 흐름을 개발자가 아닌 프레임워크에게 맡기는 것, 객체 생성 및 생명 주기 관리를 프레임워크가 담당

<IoC 컨테이너 >
: 스프링 어플리케이션의 실행을 관리, 애플리케이션 설정과 생명주기를 제어, 의존성 주입
: 빈을 생성하면서 빈이 의존하고 있는 객체를 IoC 컨테이너에서 주입하는 것!

@Configuration: 설정을 구성한다는 뜻, 스프링 설정 정보에서 사용

cf) DI는 IoC를 구현하는 방법 중 하나


[RestControllerAdvice]

@RestControllerAdvice == @ControllerAdvice + @ResponseBody
-> @ControllerAdvice와 동일한 예외 처리 역할을 수행하면서 @ResponseBody를 통해 응답으로 Json 객체를 리턴할 수 있음
-> @Controller 또는 @RestController이 붙은 컨트롤러에서 발생하는 예외를 전역적으로 처리할 수 있음

@ExceptionHandler : 특정 controller에서만 발생하는 예외만 처리하므로 여러 controller에서 발생하는 에러 처리 코드가 중복될 가능성이 있음
-> 이처럼 @RestControllerAdvice를 쓰지 않으면 예외 처리 코드 중복될 수 있음

[lombok]
: 어노테이션 기반으로 코드 자동완성 기능을 제공하는 라이브러리

<lombok 어노테이션>
@Getter: getter 메서드 생성
@NoArgsConstructor: 매개변수없는 생성자 생성
@RequiredArgsConstructor: final, @NonNull이 있는 필드를 포함하여 생성자 생성
@AllArgsConstructor: 모든 필드를 매개변수로 갖는 생성자 생성
@Builder: 빌더 패턴 적용
@Slf4j: 로그 기능

