- java의 Exception 종류들

 일반적인 예외는 흔히 컴파일 에러라고 한다. 이는 우리 서버 개발자 입장에서 인텔리제이나, VSCODE등 통합IDE를 사용하면 빨간줄로 표시되어 쉽게 확인 할수 있으니 문법적인 오류는 전공과정에서 자세히 공부하는 것이좋다.
그렇다면 우리가 다뤄야 할 Exception은 코드상에는 아무 문제가 없어보이지만 직접 실행 시켰을때 예외가 발생하는 RuntimeException이다.

1. NullPointerException(NPE) : 가장 많이 접하는 형태의 예외다. 객체가 아무것도 가지고 있지 않은 상태인 null상태일때 그 객체에 접근하려 할때 발생한다. Java로 서비스 구현을하는 개발자라면 값을 반환하는 부분이 있으면 항상 예외처리를 습관화 하자!
2. ArrayIndexOutOfBoundsException : 배열에서 할당된 인덱스 범위를 벗어날때 나타나는 예외다.
이런 예외들 이외에도 몇가지 예외들이 있지만 거의 발생하지 않는다고 생각한다. 우리는 NPE에 항상 유의하고 올바른 예외처리 로직을 구현해서 규모가 큰 프로젝트를 진행할떄 어디서 예외가 발생했는지 삽질하는 번거로움이 없도록 하는 것이 중요하다.

- @Valid

 빈 검증기(Bean Validator)를 이용해 객체의 제약 조건을 검증하도록 지시하는 어노테이션이다. Spring 개발자들이 자주 검증하는 조건을 Spring Framework에서 마련해뒀다.
@Valid 어노테이션은 다음과 같은 어노테이션들과 함께 활용할 수 있다.
@NotNull: 해당 값이 null이 아닌지 검증
@NotEmpty: 해당 값이 null이 아니고, 빈 스트링("") 아닌지 검증(" "은 허용됨)
@NotBlank: 해당 값이 null이 아니고, 공백(""과 " " 모두 포함)이 아닌지 검증
@AssertTrue: 해당 값이 true인지 검증
@Size: 해당 값이 주어진 값 사이에 해당하는지 검증(String, Collection, Map, Array에도 적용 가능)
@Min: 해당 값이 주어진 값보다 작지 않은지 검증
@Max: 해당 값이 주어진 값보다 크지 않은지 검증
@Pattern: 해당 값이 주어진 패턴과 일치하는지 검증
@Email: 이메일 형식과 일치하는지 검증

- ConstraintValidator

 위에서 언급한 @Valid 어노테이션은 일반적인 상황에 대해서만 조건을 검증해주지, 특정 DTO 필드에는 한글이 포함되면 안된다, 길이는 10자 이하여야한다 등등의 특수한 제약조건을 만족시키는 상황에 대해서는 검증을 해주지 못한다.
그러면 특수한 상황은 어떻게 검증을 할까? constraintValidator의 isValid 함수와 custom annotation을 구현하면 아예 Controller로 데이터가 들어오기 전인 Interceptor 단계에서 값을 체크하고 예외 처리를 할 수 있다.

- stream : "데이터의 흐름" 이라는 뜻을 가지고 있고, 간단하게 말하면 for문과 같은 반복자이다.

 컬렉션형태의 데이터를 쉽게 처리해주는 기능이다. 그냥 for문 사용히면 되지 굳이 stream을 사용하는 이유가 뭐냐? 이 질문에 대한 대답은 더욱 간결한 코드와 코드의 병렬처리로 인한 성능 최적화라고 생각할 수있다. 서비스의 규모가 커지면 커질수록 stream의 효과는 더욱 빛날것이다. 또한 stream을 사용하므로써 Java에서 제공하는 map, filter, reduce 등등 이외에도 많은 집계함수를 간단하게 사용할 수 있다.
