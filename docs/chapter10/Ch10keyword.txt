- Spring Data JPA의 Paging : 사용자가 어떠한 데이터를 요청했을 때, 전체 데이터 중 일부를 원하는 정렬 방식으로 보여주는 방식. 순수 spl에서 limit과 offset을 잘 조합한다면 구현할 수 있지만 Spring Data Jpa는 개발자들이 좀 더 편하게 개발할 수 있도록 Paging이라는 기술을 지원한다.
  일반적으로 Pageable 인터페이스를 통해 구현할수 있고, PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "id")의 형태로 사용자화 시켜서 인자로 넘겨주고, 필요한 형식에 맞춰서 페이징을 쉽게 구현할 수 있다.
    - Page : 각 페이지 직접 방문. 
    - Slice : 무한 스크롤. 쿼리로 전채 개수를 조회하는 것이 아닌, 다음 데이터가 있는지 없는지에 대해서만 확인할때 사용된다.
public interface Page<T> extends Slice<T> : 인터페이스의 원형이다. 사실 slice를 쓰기 위해 Jpa에서 따로 메서드를 구현한다든가 할 필요없이 편리하게 Page하나로 모두 처리할 수 있다.
Page 와 Slice 의 차이점을 간단히 말하면, count()등과 같이 집계함수의 유무로 생각해볼수 있다.

- 객체 그래프 탐색

 ORM(Object Relation Mapping)에서 데이터를 조회할때 객체지향적인 관점으로 쉽게 탐색할수 있는 방법이다.
극단적인 예시로, 다음과 같은 테이블이 각각 한번씩만 연관관계 매핑되어 있다고 생각해보자. ex) 사용자 - 대학 - 학과 - 동아리
위 예시에서 조회하고자하는 사용자가 속한 동아리를 알기 위해선 순수 sql문으로 작성한다면 join만 3번 해주어 쿼리 작성이 엄청 복잡할 것이다.
근데 객체 그래프 탐색을 이용한다면 사용자.get대학().get학과().get동아리() 이런식으로 개발자입장에서 직관적이고 간결하게 코드를 짤 수있다는 엄청난 이점이 생긴다!

- JPQL : Java Persistence Query Language의 줄임말이고, 엔티티 객체를 조회하는 객체지향 쿼리이다.

Jpa라는 편리한 기능이 있는데 굳이 이걸 알 필요가 있을까? 사실 레거시 프로젝트를 생각해본다면 순수SQL -> JPQL -> JPA 순으로 개발자가 더욱 개발하기 쉬운 강력한 기능들이 나오면서 Java 언어에서 DB의 테이블로 매핑하기 간편하게 발전해왔다. 그래도 아직까지 우리는 SQL, JPQL을 알아야한다.
 10주차 미션을 진행하면서 MemberMissionRepository.java에 JPQL을 작성했다.
사실 JPA가 정말 똑똑하게 우리의 메서드를 이름으로 판단해서 변환해주지만, 상세하고, 복잡한 경우에는 JPA가 우리가 원하는 쿼리문과 다른 엉뚱한 결과를 낼수도 있고, 작동하지 않을 수도 있기 때문이다. 이런 경우 JPQL 혹은 순수 SQL을 사용하면 해결이 된다.
 사용방법은 SQL과 크게 다를 것이 없지만 몇가지 다른점이 있다.
1. 대소문자 구분

 기본 키워드를 제외하고, 엔티티와 속성은 대소문자를 구분하기 때문에 유의해서 사용해야한다.

2. 엔티티 이름
 
 @Entity(name="abcd")
 public class User{}
위 User클래스가 있다고 생각해보자. 보통 @Entity속성을 아무것도 지정하지 않으면 JPA가 자동으로 클래스이름을 User라고 똑같이 엔티티 이름으로 매핑시켜준다. 하지만 위와 같은 경우는 사용자가 지정해서 엔티티이름을 입력해준것이므로, JPQL에서는 User를 인식하지 못하고 abcd 라고 해야 인식한다.

3. 별칭

 별칭은 필수적으로 명시해야한다. 이때 as 키워드는 생략가능하다.
