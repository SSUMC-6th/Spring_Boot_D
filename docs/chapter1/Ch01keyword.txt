1주차 키워드 정리

[TCP&UDP]
TCP와 UDP: 전송계층에서 사용되는 프로토콜
<TCP 특징>
1. 연결 지향 방식(패킷 교환 형식)
	TCP는 연결지향 방식으로 연결시에는 3-way handshaking 과정을 거치고, 해제 시에는 4-way handshaking 과정을 거침.
	연결 지향 방식으로 정확한 전송을 보장하여 신뢰성을 높임
2. 흐름제어 및 혼잡제어
	흐름제어 : 데이터 처리 속도를 조절해서 수신자의 버퍼 오버플로우 방지
	혼잡제어 : 네트워크 내의 패킷 수가 과하게 증가하지 않도록 방지
3. 수신 여부 확인
	수신 여부를 확인하며 만약 패킷이 손실되거나 잘못된 순서로 보내지는 등 문제 발생시 재전송
4. 느린 속도
	UDP보단 속도가 느림
5. 각 패킷에 고유 식별자와 번호 할당
	전송이 제대로 이루어졌는지 확인

즉, TCP는 연속성보다 신뢰성있는 전송이 중요할 때(ex.파일전송) 사용되는 프로토콜

<UDP 특징>
1. 비연결형 방식(데이터그램 방식)
	순서 보장 x, connect() x, 신뢰성 낮음
2. 데이터그램 방식
	데이터그램은 독립적인 관계를 지니는 패킷으로 패킷 마다 고유 식별자 x
	전송순서가 바뀔 수 있음
3. 흐름제어 x
4. 수신 여부 확인 x
5. 빠른 속도
	TCP보다 빠름

즉, UDP는 신뢰성보다는 연속성이 중요한 서비스(ex.실시간 스트리밍)에 사용되는 프로토콜

[시스템콜]
- 운영체제 : 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스 역할
- 커널 : 프로세스 관리, 메모리 관리, 저장장치 관리 등 운영체제의 핵심적인 기능을 모아둠
- 시스템콜
: 프로그램이 특권 명령의 수행을 필요로 하는 경우, 운영체제에게 특권 명령의 대행을 요청하는 것

- 시스템 콜이 필요한 이유 :
우리가 일반적으로 사용하는 프로그램은 응용 프로그램으로 이는 유저레벨임 
-> 커널모드로 전환한 후에야 작업할 수 있는 것들이 존재하기에 시스템콜을 이용.

즉, 응용 프로그램은 시스템 콜을 사용해서 원하는 기능을 수행함 
-> 시스템콜은 커널 영역의 기능을 사용자 모드가 가용 가능하게, 즉 프로세스가 하드웨어 직접 접근해서 필요한 기능을 할 수 있게 해줌.

(cf. 시스템 콜 vs 드라이버)
응용 프로그램 <->커널 : 시스템 콜
커널 <-> 하드웨어 : 드라이버

[하드웨어 인터럽트]
- 인터럽트 : 프로그램 실행 중 예기치 않은 상황이 발생하면 현재 실행중인 작업 일시 중단하고 발생된 상황 우선처리한 후에 실행중이던 작업으로 다시 복귀하여 계속 처리하도록 하는 것.
- 인터럽트가 필요한 이유 : 멀티태스킹을 위해!
- 과정 : 인터럽트가 발생하면 현재 실행 중인 프로세스는 중단되고, 운영체제는 해당 인터럽트를 처리하는 인터럽트 핸들러를 호출하여 해당 작업을 수행
- 하드웨어 인터럽트 
: 외부 장치 또는 하드웨어에서 생성되는 인터럽트 
: 운영체제가 처리해야 할 이벤트가 발생 시, 하드웨어나 주변 기기가 CPU에게 신호를 보내어 발생

(cf.소프트웨어 인터럽트)
- 소프트웨어 인터럽트 
: 컴퓨터의 내부 시스템에서 생성되는 인터럽트로 시스템 콜을 통해 발생함
: 커널과 통신해 간접적으로 중앙 처리 장치를 인터럽트

(cf.trap vs interrupt)
- Interrupt : 외부 장치 또는 소프트웨어 인터럽트 요청에 의해 발생
- Trap : 프로세스 내부에서 예외 상황이 생겼을 때 발생

[리눅스의 파일과 파일 디스크립터]
리눅스 시스템에서는 모든 것이 파일로 모든 객체와 행동은 파일로 관리됨
리눅스에서 프로세스가 파일에 접근할 때 파일 디스크립터 사용됨
- 파일 디스크립터 
: 프로세스가 파일을 다룰 때 사용하는 것으로 운영체제가 특정 파일에 할당해주는 정수값
:  응용 프로세스가 파일을 열거나 생성하면 정수로 된 파일 디스크립터를 얻게 되는데, 이 파일 디스크립터는 이후에 일어나는 모든 파일 동작에서 그 파일을 가리키는데 사용됨

[socket() 시스템 콜]
- 형식 : socket(주소영역 지정, 서비스 타입, 프로토콜 지정)
- 소켓 생성 후 생성된 소켓의 디스크립터 반환하는 시스템 콜
- TCP와 UDP를 사용하려면 socket() 시스템 콜을 사용함

[bind() 시스템 콜]
- 형식 : bind(소켓, 바인드될 소켓의 주소, 주소크기)
- 생성된 소켓에 주소를 부여함

[listen() 시스템 콜]
- 서버 프로세스에서 실행
- 소켓을 활성화함
- 소켓에서 대기할 수 있는 연결 요청의 개수를 지정하는 역할
- backlog : 연결 요청 개수

[accept() 시스템 콜]
- 서버 프로세스에서 실행
- 형식 : accept(소켓, 주소, 주소의 길이)
- 서버 프로그램에서 클라이언트의 연결 요청을 대기하는 역할
- 연결 요청이 들어오면 둘 사이의 연결 설정되고 -> 서버에 새로운 소켓이 생성!! -> 이후 데이터 송수신은 새로 생성된 소켓을 이용하여 이루어짐

[connect()]
- 클라이언트 프로세스에서 사용
- 클라이언트 프로그램에서 서버에게 연결 요청을 수행하는 함수
- 매개변수로 설정된 주소값이 가리키는 서버와 연결을 설정

[멀티 프로세스]
- 멀티 프로세스
: 여러 개의 프로세스가 서로 협력적으로 일을 처리
: 여러 개의 프로세스가 작업을 병렬처리
: 각 프로세스 간의 메모리 구분! -> 독립된 구조로 안정성이 높음

(cf.멀티 스레드)
- 멀티 스레드
: 하나의 작업을 위해 프로세스에서 여러 스레드를 생성해 여러 CPU 코어를 사용하기 위한 작업

즉, 멀티 프로세스가 하나의 운영체제에서 여러 프로세스가 실행되는 것이라면,
멀티스레드는 하나의 프로세스가 여러 작업을 여러 스레드를 사용하여 동시에 처리하는 것

[병렬 처리]
- 병렬처리 
: 여러개의 작업을 동시에 실행해서 효율을 높임. (ex.멀티 프로세스 & 멀티스레드)
: 두개 이상 다수의 프로세서가 협력적으로 하나 이상의 작업을 동시에 처리하는 것

(cf. 동시성 vs 병렬성)
- 동시성 : CPu core가 1개 -> 여러 프로세스를 짧은 시간동안 번갈아 가면서 연산하는 시분할 시스템으로 실행
- 병렬성 : CPU core가 여러개 -> 각각의 core가 각각의 프로세스를 연산함으로써 프로세스가 동시에 실행되는 것

