- 영속성 컨텍스트 : 임의의 저장공간

 우선 Spring Data Jpa는 Spring MVC 프레임워크에서 제공하는 ORM(Object Relation Mapping)의 기능을 제공한다.
간단하게 Java는 객체지향언어이고, Java를 언어로 사용하는 Spring 프레임워크는 객체이지만, Oracle, MySQL, 더 나아가서는 NoSQL인 Redis 등등 이런 DB에 대한 데이터 형식으로의 변환이 필요하다. 레거시 프로젝트를 보면 순수 SQL문, JDBC 등등 불편하게 변환했지만 Spring Data 기능을 통해 개발자입장에서 매우편하게 객체를 DB에 매핑 시킬수 있다.
이 편리한 JPA에서 핵심이 되는 것이 바로 영속성 컨텍스트이다. 
 @Entity라고 어노테이션을 붙이면 "그 클래스는 JPA가 관리하겠다!"라는 의미이고, JPA에서 영속성 컨텍스트를 관리하는 엔티티 매니저에 의해 저장된다.
중요한건 영속성 컨텍스트에 저장되었다고 한다면 실제 DB(우리의 경우 MySQL)에는 저장되지 않는다.

- 트랜잭션 : 한번에 수행되는 작업

 영속성 컨텍스트에서 DB로 저장되는 과정을 알기 위해 트랜잭션을 알아야한다.
Ex) 친구에게 카카오페이로 송금하는 경우 : 만원을 보내는 중간에 갑작스럽게 서버에러가나면 만원을 아예 보내던가 아예 안보내던가 둘중 하나만 하는것이 당연할것이다.
내 통장에서 만원이 빠져나갔는데, 친구는 만원을 안받았다고 하면? 대참사다.
이런 것들을 해결하기 위한것이 바로 트랜잭션이다. 트랜잭션은 가장 중요한 ACID(원자성, 일관성, 고립성, 지속성) 4가지 원칙을 지키면 위와같은 대참사가 일어나지 않는다.

- commit / partially commit

한번에 수행되는 작업을 위해 트랜잭션을 사용하고 그러면 DB에 연속적으로 반영이 되어야할것이니까 영속성 컨텍스트를 통해 쿼리문을 모아뒀다가 한번에 DB에 반영한다.
언제? 트랜잭션이 commit 되는 순간이다. 물론 이 commit 자체도 메모리 vs 디스크(or 클라우드) 관점에서 봤을때는 완전히 commit 된것이 아닌 partially commit 상태로 메모리 DB와 메모리 로그에만 commit된것이다. 그러면 언제 디스크(or 클라우드)에 저장이 되냐? OS에 의해서 일정 간격으로 저장한다. 그 이후부터 복구같은 작업이 가능해진다.

- flush : 진짜  DB에 저장

 commit할때 자동으로 flush를 실행하면서 영속성 컨텍스트에 있는 쿼리가 DB에 반영된다.
JpaRepository를 사용할때 save()함수와 saveAndFlush()라는 함수가 있는데, 이때 flush를 강제하게 되면 트랜잭션중 일부만 DB에 즉각 반영되게 할수 있다.
특수한 경우에 우리가 제어할수 있다는 점이다. 또한 JPQL을 쓰면 flush를 자동호출한다.

- 지연로딩 @ManyToOne(fetch = FetchType.LAZY) VS 즉시로딩 @ManyToOne(fetch = FetchType.EAGER)

 @ManyToOne, @OneToOne 의 fetch 타입의 기본값은 FetchType.EAGER이다. 나머지 두개는 LAZY
즉시 로딩의 경우 hibernate는 SQL조인을 이용해서 연관된 데이터를 모두 가져온다. 이는 find할때 예상 못하는 쿼리가 발생할수 있어서 특수한 경우를 제외하고는 LAZY로 설정하는 것이 좋다.

- 양방향 매핑

객체 그래프 탐색을 위해 매우 중요하고, 연관관계에 의한 데이터 변화를 전체에 적용하기 위해 쓰인다.
특히 cascade 설정을 할 경우, 한쪽 엔티티에만 설정되어 있으면 올바르게 작동하지 않는다.
왜? 실제 DB는 관계형이고, 스프링의 경우 객체로 나타나는데, 관계형 DB에서는 참조 무결성 제약을 지키기 위해 연관관계주체인 테이블에서 cascade설정을 해줘야한다. 
JPA에서는 연관관계주체가 아닌 엔티티를 부모 객체로 취급하므로, 자식에 해당되는 연관관계주체에 cascade설정을 해주게 된다면 다른 자식 객체들 모두 이 설정을 해줘야할것이다. 따라서 부모 객체인 엔티티에 cascade설정을 해줘야한다. 
정리하자면 JPA랑 DB랑 cascade설정 하는 객체(테이블)이 반대가 되야한다. 이것이 JPA에서 양방향 매핑을 해줘야하는 이유이다.

- N + 1 문제 : 한쪽 테이블만 조회하고 연결된 다른 테이블은 따로 조회하기 때문에 발생하는 문제이다.

ORM 즉 JPA를 사용하면서 나타날수 있는 문제이다. 1:N 으로 연관관계 설정이되어있을때, 1에 대해 쿼리를 날리면 조회된 데이터 갯수(n) 만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. EAGER 전략일때 연관된 데이터를 모두 가져오므로 당연히 N+1 문제가 발생한다. 그러면 LAZY전략이면 문제가 발생안하는가? 답은 NO이다. LAZY 전략의 경우 find나 findAll로 쿼리를 날리는 시점에는 이상이 없겠지만, 객체 그래프 탐색 등 가져온 쿼리에 대한 데이터로 연관관계가 있는 엔티티에 대한 정보를 호출하면 그 시점에 N+1문제가 발생한다. 
성능상 이슈가 중요한 경우에는 이 문제를 피하는것이 좋다. 어떻게? QueryBuilder 또는 @Query를 이용한 fetch  join을 활용하는것이다.

- @EntityListeners(AuditingEntityListener.class)

이번 워크북에서 BaseEntity에 사용된 어노테이션이다.
인자에 있는 Auditing의 의미는 '변경되는 시점감지'를 의미하는데, updateAt의 시점을 감지해서 설정값을 반영해주기위해 사용한다.
